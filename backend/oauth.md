# OAuth 2.0 Flow Step-by-Step Guide

This document outlines the standard Authorization Code Grant flow, commonly used for web applications.

## Key Concepts

*   **Resource Owner:** The user who owns the data being accessed (e.g., their Google profile).
*   **Client (Your Application):** The application requesting access to the user's data (your FastAPI backend).
*   **Authorization Server:** The server that authenticates the Resource Owner and issues access tokens (e.g., Google, GitHub).
*   **Resource Server:** The server hosting the protected resources (e.g., Google's user info API, GitHub's user email API).
*   **Authorization Grant:** A credential representing the Resource Owner's authorization (the `code` in this flow).
*   **Access Token:** A credential used to access protected resources on behalf of the user.

## Flow Diagram (High-Level)

1.  **Authorization Request:** User clicks "Login with Google/GitHub" on your app.
2.  **Authorization Grant:** User approves access on Google/GitHub.
3.  **Authorization Grant (Code):** Google/GitHub redirects back to your app with a `code`.
4.  **Access Token Request:** Your app exchanges the `code` for an `access_token`.
5.  **Access Token Grant:** Google/GitHub provides an `access_token` and optionally a `refresh_token`.
6.  **Resource Access:** Your app uses the `access_token` to fetch user data.
7.  **Protected Resource:** Google/GitHub returns the user data.

---

## Detailed Step-by-Step Flow

### 1. Client (Your App) Initiates Authorization Request

*   **Action:** The user in your frontend application clicks a "Login with Google" or "Login with GitHub" button.
*   **Client Redirect:** Your frontend redirects the user's browser to the Authorization Server's (Google/GitHub) authorization endpoint.
*   **Parameters sent:**
    *   `client_id`: Your application's public identifier.
    *   `redirect_uri`: The URL where the Authorization Server will send the user back after authorization. This **must** be pre-registered with the Authorization Server.
    *   `response_type=code`: Specifies that you're requesting an authorization code.
    *   `scope`: A space-separated list of permissions your app is requesting (e.g., `openid email profile` for Google, `user:email` for GitHub).
    *   `state`: (Highly recommended) A unique, unguessable value generated by your app to prevent CSRF attacks. The Authorization Server will return this value unchanged.

### 2. Resource Owner (User) Authorizes the Client

*   **Action:** The Authorization Server (Google/GitHub) presents a login page (if the user isn't already logged in) and an authorization consent screen to the Resource Owner.
*   **User Decision:** The user either grants or denies your application's request for access.

### 3. Authorization Server Issues Authorization Grant (Code)

*   **Action (Success):** If the user grants access, the Authorization Server redirects the user's browser back to your `redirect_uri` with an authorization `code` and the `state` parameter (if provided).
*   **URL Example:** `http://localhost:8000/auth/google/callback?code=AUTH_CODE_FROM_GOOGLE&state=YOUR_CSRF_TOKEN`
*   **Action (Failure):** If the user denies access or an error occurs, the Authorization Server redirects back with an error message.

### 4. Client (Your App) Exchanges Authorization Code for Access Token

*   **Action:** Your backend receives the `code` at the `/auth/google/callback` or `/auth/github/callback` endpoint.
*   **Client Request:** Your backend makes a **direct (server-to-server)** POST request to the Authorization Server's token endpoint. This request is **not** done via the user's browser.
*   **Parameters sent:**
    *   `client_id`: Your application's public identifier.
    *   `client_secret`: Your application's confidential secret.
    *   `code`: The authorization code received in the previous step.
    *   `redirect_uri`: The same `redirect_uri` used in step 1.
    *   `grant_type=authorization_code`: Specifies that you are exchanging an authorization code.

### 5. Authorization Server Issues Access Token (and optionally Refresh Token)

*   **Action:** If the `code` is valid, the Authorization Server responds to your backend with a JSON object containing:
    *   `access_token`: The token your application will use to access protected resources.
    *   `token_type`: (e.g., `Bearer`).
    *   `expires_in`: (Optional) The lifespan of the access token in seconds.
    *   `refresh_token`: (Optional) A long-lived token used to obtain new access tokens when the current one expires, without re-prompting the user.
    *   `scope`: (Optional) The actual scopes granted.

### 6. Client (Your App) Accesses Protected Resources

*   **Action:** Your backend uses the `access_token` to make authenticated requests to the Resource Server (e.g., Google's `userinfo_url`, GitHub's `api.github.com/user`).
*   **Request Header:** The `access_token` is typically sent in the `Authorization` header as a Bearer token: `Authorization: Bearer YOUR_ACCESS_TOKEN`.
*   **Parameters sent:** Any parameters required by the specific resource API.

### 7. Resource Server Returns Protected Resource

*   **Action:** The Resource Server (Google/GitHub) validates the `access_token`. If valid, it returns the requested user data (e.g., email, username, profile picture).
*   **Your App's Logic:**
    *   Use the received user data (email, provider ID) to find an existing user in your database.
    *   If the user exists, log them in (e.g., by generating your own JWT for your application).
    *   If the user exists but without the specific OAuth provider ID, link their existing account to the new OAuth provider.
    *   If the user does not exist, create a new user account in your database using the OAuth provider's information and then log them in.

This completes the OAuth flow, allowing your application to securely access user data from third-party services.
